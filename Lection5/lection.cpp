//!!!  ПРОСТРАНСВО ИМЕН !!!
struct Array2D {
 int M, N;
 double  **p;
 }
//реализуем 
//печать print
//считывание input
//инициализация init
//копирование copy 
 
введем
namespace Array2d {
   
    void print(const Array2D &A); //константная ссылка на тип Array2D
    void input(Array2D &A); //сслыка по которой можно менять содержимое, указатели
    void init(Array2D &A);
    void copy(Array2D &to, const Array2D &from);
}    
    
 типовое использование 
include "Array2d.h"
int main() {
    Array2D x;
    Array2d::init(x);
    
    или можно сделать так
    using namespace Array2d; 
    и дальше можно писать (но только в пределах функции)
    init(x);
    print(x);    
    
}       
  
если уже структура написана, то мы не можем ее дополнять.
 но можем дополнять пространство имен
 например namespace Zoo{
   struct Panda{} } добавили новую структуру к уже сущ. пространству емен  
простраство имен  метод структуирования имен (сортировка), для удобства

 
!!! ПЕРЕГРУЗКА ИМЕН ФУНКЦИЙ !!! 
(нет в чистом С) 
Перегрузка бывает 
1) по количеству аргументов
double  abs(double x);
double abs(double x, double y);
2)
Сначала точное совпадение
a) по типу аргументов
если нет функции точно совпадающей по типу произодйет приведение типа (характер продвижение вверх float -> double -> int (есть разные знаковые беззнаковые и разных длин))
беззнаковые имеют приоритет над знаковыми 

б)другое встроенное приведение типов 

в)пользовательское приведение типа (волка превратить в целое число)  

г)если ничего не нашелось, то эллипсис - функция с переменным количеством аргументов 
3) по возвращаемому типу
int abs(int x);
double abs(int x); 
В СИ++ ТАКОГО НЕТ ! 
!!! АРГУМЕНТЫ ФУНКЦИИ ПО УМОЛАНИЮ В С++ !!!


void hello(int number, 
           char sep) //печатется naber раз с разделителем sep
{
    if (number == o) return;
    for ( int i = 0; i<number -1, i++)
    {
        cout << "hello" << sep; 
    }
    cout << "hello" << endl;
}           

а если зохотим вызывает ее как:
hello() //пусть печатает один раз с переводом картки
hello(5) // 5 hfp c gthtdjljv rfhnrb
hello(3, '_') //hello_hello_hello 

делается это так: void hello(int number = 1, char sep = "\n");

А если есть void hello(double number = 1, char sep = "\n");
и мы вызываем hello(5). Какая же вызовется? 
Та, где строго совпали типы. 

 
 
 
